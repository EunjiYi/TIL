### 카운팅 정렬(Counting Sort)

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, `선형 시간`에 정렬하는 효율적인 알고리즘



제한사항

- 정수로 표현될 수 있는 자료에 대해서 가능

- `가장 큰 정수`를 알아야되는데 그게 막 30억이면 힘들겠지? (0~30억이니까 30억+1짜리 배열을 만들어야...)

- 숫자, 문자(1자) 카운팅정렬 가능

- 문자열, 실수는 카운팅정렬 안됨( 인덱스 값이 있어야한다.) but 실수가 소수점 몇 자리(ex. 소수점 두 자리)까지 있다고 정해져있으면(ex. 곱하기 100 해서 카운팅하면 되니까) 카운팅정렬 가능

  ```
  정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능: 각 항목의 발생회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다!
  
  카운트를 위한 충분한 공간을 할당하려면 집합 내의 `가장 큰 정수`를 알아야한다.
  
  시간복잡도 O(n+k): n은 리스트의 길이, k는 정수의 최댓값
  ```



카운팅정렬과정

1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트배열 counts에 저장한다.

   > counts[0] = 0의 발생횟수
   >
   > 즉, counts[i] = i의 발생횟수

2. 정렬된 집합에서 `각 항목의 앞에 위치할 항목의 개수를 반영`하기 위해 `counts의 원소를 조정`한다.

3. counts[1]을 감소시키고 temp에 1을 삽입한다.(정렬할 배열 맨 뒤부터 앞으로.)

4. counts[4]을 감소시키고 temp에 4을 삽입한다. .... ex) [0,4,1,3,1,2,4,1]

5. temp 업데이트를 완료하고 정렬 작업을 종료한다.

=> 즉, 원본이 있고, 결과물이 따로 있다. 다시말해 결과물을 저장할, 원본만큼의 크기의 배열이 하나 더 필요하다. temp에 완성된 걸 다시 원본에 넣어줘야 정렬기능을 유효하게 사용할 수 있다. cf. Marge 소트도 temp 필요





* 정렬방식 중에서 시간복잡도 O(n^2)를 가지는 정렬을 세가지 쓰시오 : 버블정렬  선택정렬  삽입정렬



----------

------------

### 완전검색(Brute-force, Generate-and-test, Exaustive Search)

완전검색방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.

모든 경우의 수를 테스트한 후, 최종 해법을 도출한다. 

상대적으로 경우의 수가 작을 때 유용하다.

모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

* 시험볼때(im 등등) 우선은 완전검색으로 접근하여 해답을 도출한 후에, 성능개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다. 



```
오늘 우리가 할 완전검색은 for문

실제 완전검색은 다른 알고리즘을 사용한다. 
`가지치기` + `완전검색을 재귀로( dfs 깊이우선탐색)` = `BT(백트래킹)`

순열, 조합, 부분집합은 재귀로. 
-조합은 뽑기만 하는 것, 순열은 뽑아서 나열한 것
-시험문제에서는 nPr보다는 nPn이 많이 나옴. 주어진 것 다 줄세우기(원소의 갯수가 6개면,, for문 6개! 그러니 재귀로 하자.)
```



--------

------



### 탐욕 알고리즘

최적해(답이 여러개 있을 때 제일 좋은 것)를 구하는데 사용되는 근시안적인 방법

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.

각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여도,그것이 최적이라는 보장은 없다.

일반적으로 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 그리디접근.

> 별로 좋은 방법은 아니다 정도. 되도록이면 완전검색을 써라 ~





#### ex. 거스름돈 줄이기

> 거스름돈 800원:처음에 제일 큰 500원짜리 줌 -> 800원 보다 작으니까 ok -> 다시 또 500원을 줌 남은 돈 300원보다 크니까 안됨 -> 그러면 다시 1번으로 가서 100원을 줌 -> 300원보다 작으니까 가능 -> 이 루트 반복



> 그런데 만약, 갑자기 조폐공사에서 400원짜리 동전을 만들었다!
>
> 그러면 , '그리디하게 풀리지 않는다!' 그리디로하면 500원(제일큰 500원 먼저 픽하고 남은 300원을 100원 3개로 줌) + 100원 + 100원 + 100원 이잖아. 
>
> 그런데 이 문제의 답은 400 400 이니까.! = 그리디는 될 수도 있고 안 될 수도 있다. 그러니까 완전검색을 해라 ~~ ㅋㅋ (but 완전검색이 더 좋은 방법이라고 했는데 베이비진이 탐욕으로 풀림 ㅋㅋ 베이비진은 꼭 순열로 풀어보자.)
>
> > 잘못된 그리디 접근 예
> >
> > Q. 6개를 정렬해서 판단하면 안되나?(그리디한 접근)
> >
> > A. 정렬로 안되는 테스트 케이스를 들어보세요. 123123   012223  
> >
> > 즉, 탐욕알고리즘은 해답을 찾아내지 못하는 경우도 있으니 유의해야한다.!



#### 거스름돈으로 보는 탐욕알고리즘의 동작 과정

1. 해선택 : 현재 상태에서 가장 좋은 해 고르기 = 500원고른다.
2. 실행가능성 검사: 새로운 부분해집합이 실행가능한지, 문제의 조건을 위반하지 않는지 검사
   - 다시 또 500원을 줌 남은 돈 300원보다 크니까 안됨 -> 그러면 다시 1번으로 가서 100원을 줌 
3. 해검사: 새로운 부분해집합이 문제의 답인지 확인. 
   - 거스름돈은 많아도 적어도 안되고 딱 맞아야함. 액수모자르면 다시 1번으로 가서 추가할 동전 골라야함.



+

babygin 문제를 그리디하게 푸는 법

`counts배열의 각 원소를 체크`하여 run과 triplet 및 baby-gin 여부를 판단한다. 

