200727_3_error_exception



 에러(Error) = 코드가 문법적으로 문제, 명확하게 잘못이 있어서 비교적 찾기가 쉽다.

* `파일이름`과 `줄번호`, `^`(캐럿) 문자를 통해 파이썬이 코드를 읽어 들일 때(`parser`) 문제가 발생한 위치를 표현한다.
>> 파서란, 우리가 짠 코드로부터 의미를 도출해내는 기기 . 파이썬 코드를 해석하는 주체
>> 내가 짠 코드를 실제 컴퓨터가 이해하는 코드로 옮겨가는 과정에 있는 통역가 같은 친구. 여기서 에러가 났다. 내가 이걸 해석을 못하겠다 = Syntax Error

SyntaxError 문법적인 에러, 주로 오타. 문법 에러가 있는 프로그램은 실행되지 않는다.

> 에러 상세 내용 차이
>
> - invalid syntax  # :같은거빠졌을때 , 오타 등
>
>   ​							# 정확한 위치를 지정하지 않을 수도 있으므로 지정된 위치 전후를 모두 확인 `if True print('참')` - True에 :가 없어서 문제인데 캐럿이 print에 n을 가리킴. 비정확할 때도 있다.
>
> * EOL 오류(따옴표 오류)  #스트링을 열어놓고 닫지 않는 경우 `print('hi)`
> * EOF 에러(괄호 닫기 오류)  # 닫는 괄호 없애기 `print('hi'`





**예외(Exception)** = 실제로도 돌아가고, 문법적으로는 옳지만, 의미적으로 이뤄질 수 없거나 특정한(예상치못한) 입력값이 들어와서 코드가 돌다가 중간에 멈추는 등

> 실행 도중 예상하지 못한 상황(exception)을 맞이하면, 프로그램 실행을 멈춘다. 

* 문법적으로는 옳지만, 실행시 발생하는 에러.

```python
* *아래 제시된 모든 에러는 `Exception`을 상속받아 이뤄진다.*
ZeroDivisionError: 0으로 나누었을 때
NameError: 정의되지 않은 변수를 불러올 때
TypeError: 자료형에 대해 잘못된 사용방법이 들어갔을 때, 데이터타입이 잘못 되었을 경우(1 + '1'), 함수 호출과정에서 원하지 않는 인자가 들어갔을 때도 발생한다->(round('3.5') 수가 들어가야되는데 글자가 들어갔다.). 인자 갯수 알맞게 입력안해도 발생, 인풋 잘못 넣었을 때도 발생
ValueError: 자료형에 대한 타입은 올바르나, 값이 적절하지 않은 경우 ex.int('3.5')-> '3'이면 잘 돌아감. '3.5'가 float이라서 그래. 존재하지 않는 값을 찾거나 조회하려고 하는 경우
IndexError: 유효하지 않은 인덱스를 호출할 때, 범위를 벗어난 인덱스로 접근하려할 때 empty_list[-1] # 비어있는 리스트인데 마지막값을 조회하니까.
KeyError: dictionary안에 없는 키에 접근하려 할 때
ModuleNotFoundError: 사용하려는 모듈을 찾을 수 없을 때, 존재하지 않는 모듈을 가져올 때
ImportError: 모듈은 찾았으나 가져오는 과정에서 실패하는 경우, 클래스나 메서드 이름이 잘못되었을 때, 존재하지 않는 클래스나 함수를 호출할 때
KeyboardInterrupt: 중간에 키보드를 통해 종료됨(ctrl+c)
    while True:
    continue
```

#### #  choice : 특정한 리스트 혹은 이터러블타입 데이터 컨테이너 안에 들어있는 값을 랜덤하고 뽑아줌.  random.choice
----------------------

-----------------





###  예외 처리(Exception Handling) 예외발생했다고 실행이 다 멈춰버리면 안되잖아. 예외 발생하면 코드실행 자체가 멈추지 말고 이런이런 식으로 해결하자~ 넘기는 법

###  `try` & `except`

* try부분의 코드블락이 실행되다가, 예외가 발생되지 않으면 **`except`없이 실행이 종료 된다.**
* 예외가 발생하면, **남은 부분을 수행하지 않고**, `except`가 실행된다.

추가로,

**에러 메시지 처리` as`**
as 키워드를 활용하여 에러 메시지를 보여줄 수도 있다.

```
try:
    <코드 블럭 1>
except 예외 as err:
    <코드 블럭 2>
```



복수의 예외처리는 

```python
try:
    <코드 블럭 1>
except (예외1, 예외2):
    <코드 블럭 2>
```



여기서 중요한건 **에러가 순차적으로 수행됨**. 가장 작은 범주부터 시작해야함.

```python
#
try:
    num = input('100으로 나눌 값을 입력하시오: ')
    100/int(num)
except Exception: #예외범주 젤 큰 것. 
    print('에러가 났어요.') 
except ValueError: # Exception에러를 먼저 잡아버려서 input으로 '값'이라 입력했는데 
    # '글자가 아닌 숫자를 입력해주세요.'가 아닌
    #에러가 났어요.'' 가 나옴.
    print('글자가 아닌 숫자를 입력해주세요.')
except ZeroDivisionError:
    print('0으로는 나눗셈을 할 수 없습니다.')
```



써보니까 은근 유용한 `else`

에러가 발생하지 않는 경우 실행 시킬 문장은 `else`를 활용한다.
* `else`는 `except` 코드 뒤에 와야 한다.
* `try` 코드 블럭이 예외를 일으키지 않았을 때, 실행되어야 하는 코드에 사용된다.



<-> 비교 잘하기

### `finally`

- 어떤 경우에든 반드시 실행해야하는 코드에는 `finally`를 활용 = 모든 상황에 실행되어야만 하는 코드를 정의= 예외의 발생 여부과 관계없이 항상 실행.

--------------



`+`

+ 예외를 일부러 발생시킬수도 있다. 오잉

`raise`를 통해 강제로 `예외 발생 시키기(Exception Raising)

```python
raise <에러>('메시지')
```



raise #아무것도 없이 딱 raise만 적으면 런타임에러 남

```
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-26-a8a450a3c987> in <module>
      1 #
----> 2 raise

RuntimeError: No active exception to reraise
```



raise NameError('이름이 없습니다.') # 원하는 에러 발생시킨다

```
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-27-ae8ce733613b> in <module>
      1 #
----> 2 raise NameError('이름이 없습니다.') # 원하는 에러 발생시킨다

NameError: 이름이 없습니다.
```

ㅋㅋㅋ고러쿤