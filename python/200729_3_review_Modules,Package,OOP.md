0729 복습

### 1. Module

* 모듈 : 특정 기능을 하는 변수, 함수, 클래스 코드를 .py나 스트립트 단위로 작성한 것
* 패키지: 특정 기능과 관련된 여러 모듈의 집합, 패키지는 또다른 서브 패키지를 가질 수 있음.
* 라이브러리: 모듈과 패키지들의 집합(파이썬 표준 라이브러리 PSL)
* 패키지 관리자: 외부 패키지(PyPI에 등록된 패캐지)를 설치할 수 있게 도와주는 패키지(pip)



### 모듈의 활용

* import를 통해서 모듈을 이름공간으로 가져와야한다.
* `import 모듈명`
* 해당 모듈안에 있는 `from 모듈 import 변수, 함수, 클래스`를 선택적으로 불러올 수 있다.
* `from 모듈명 import *`



### 패키지의 활용

* 점(.)으로 구분된 모듈이름(`패키지명.모듈명`)을 써서 모듈을 구조화하는 방법
* `from 패키지명 import 모듈명`
  * `모듈명.변수명` `모듈명.함수명` `모듈명.클래스명`
* `from 패키지명 import 모듈명 as 별명`
  * `별명.변수명` `별명.함수명` `별명.클래스명`
* `from 패키지명.모듈명 import 변수, 함수, 클래스`
  - `변수명, 함수명, 클래스명` - 네임스페이스로 가져왔기 때문에 해당 이름으로 바로 사용 가능.
* `from 패키지명.모듈명 import *` #사용하지도 않는데 메모리 불러온다면, 나중에는 비용적인 측면에서도 안좋으니 잘 생각하고 쓰자.

```python
import datetime
print(datetime.datetime.now()) #모듈명.클래스명.메소드명

from datetime import datetime
print(datetime.now()) #보기에 더 편안하게 바꿔보자

from datetime.datetime import now #이러면 module not found에러 난다. now()는 메소드라서 안됨. 함수는 불러올 수 있는데 메소드는 안됨.
```



### 모듈을 찾는 순서

1. 실행하는 파일의 경로에서 import하는 모듈(.py)을 검색
2. 파이썬에서 제공하는 라이브러리(python standard library)에서 모듈을 검색
3. 외부 패키지에서 모듈을 검색

----



### OOP

* 객체: 같은 종류를 모아놓은 집합체, 즉, 속성(설명 가능한 특성)과 행동요소(조작법)를 가지는 것

* Class: 객체를 표현하는 문법, 설계도 - 붕어빵틀, 필름

  * 파이썬으로 클래스를 표현할 때는 파스칼 케이스를 클래스명으로 사용한다. 

    ```python
    class ClassName:
        <attrubutes>
        <methods>
    ```

* 인스턴스: 클래스로부터 생성한 개별적인 대상 - 붕어빵, 사진
  * 자신만의 속성을 가질 수 있다.
  * 클래스에서 정의한 속성(attributes)이나 행위(methods)를 수행할 수 있다.

* 속성: 클래스나 인스턴스에서 가지는 데이터
* 메서드: 클래스나 인스턴스가 할 수 있는 행위

----



* 생성자: 인스턴스 객체가 생성될 때 자동으로 호출되는 함수

  ```python
  class ClassName:
      def __init__(self) #더블언더스코어 = 던더
      	print('생성될 때 자동으로 호출되는 생성자')
  ```

* 소멸자: 인스턴스 객체가 삭제될 때 호출되는 함수

  ```python
  class ClassName:
      def __del__(self):
          print('삭제될 때 자동으로 호출되는 소멸자')
  ```

* `self` : 인스턴스 자기자신

  * 파이썬에서 메서드가 호출될 때 첫번째 인자로 인스턴스 자신이 알아서 전달됨. self 가 이름이 고정된 건 아님. 매개변수라서 이름 마음대로 바꿀 수는 있지만, 컨벤션으로 self씀. 가급적 self를 쓰도록하자.

  

-------



### 인스턴스 변수/ 클래스 변수

* 인스턴스 변수
  * 각 인스턴스의 고유한 변수
  * **생성자에서 `self.변수명`로 정의**
  * 인스턴스가 생성이 되면 `인스턴스명.변수명` 접근 및 할당 가능
* 클래스 변수 
  * 클래스가 가지고 있는 변수이며 모든 인스턴스가 공유
  * 클래스 선언 내부에서 정의
  * 클래스가 생성되면 `클래스명.변수명` 또는 `인스턴스명.변수명` 으로 접근 및 할당 가능.
* 이름공간탐색
  * 클래스를 생성하면 동시에 클래스의 이름공간이 생성됨.
  * 인스턴스를 만들면 인스턴스 객체가 클래스 이름공간에 생성됨.
  * 인스턴스 변수가 변경되면, 변경된 데이터는 인스턴스 객체 이름공간에 저장됨. - 인스턴스변수는 인스턴스가 가지는 각각의 고유의 변수이기 때문에 
  * 탐색순서: 인스턴스 이름공간 -> 클래스 이름공간 -> 글로벌 이름공간

-----



### 인스턴스메소드 / 클래스메소드(스태틱메소드)

* 인스턴스메소드

  * 인스턴스가 사용하는 메소드
  * **클래스 내부에 정의되는 메소드는 기본적으로 인스턴스메소드가 된다.**
  * 호출 시 첫 번째 인자로 인스턴스 자기자신이 self 로 전달됨.

* 클래스메소드

  * 클래스가 사용하는 메소드
  * 클래스 내부 변수에 접근할 때 주로 사용
  * 클래스 메소드를 정의할 때 `@classmethod` 이라는 데코레이터를 사용해서 정의
  * 호출시, 첫 번째 인자로 클래스를 `cls`에 전달됨.

* 스태틱메소드

  * 클래스가 사용하는 메소드
  * 스태틱메소드를 정의할 때 `@staticmethod`라는 데코레이터를 사용해서 정의
  * 호출 시 어떠한 인자도 전달되지 않음.

* 비교정리

  * 인스턴스는 3가지 메소드에 모두 접근할 수는 있다. 

    * 그렇다고 이걸 사용하지는 말자. 인스턴스는  인스턴스메소드만 호출해야한다. 그래서 인스턴스가 할 행동은 모두 인스턴스메소드로 한정지어서 설계해야함! 구분을 지어주자.

  * 클래스도 3가지 메소드에 모두 접근할 수는 있다. 

    * 그렇다고 이 역시 사용하지는 말자. 클래스도 인스턴스메소드는 호출하지 않는다. 클래스가 정의한 클래스메소드만 접근할 수 있도록 설계하자. (가능하다 != 사용한다)

    * 클래스가 할 행동은, 다음 원칙에 따라 설계한다.

      > `클래스 자체(cls)와 그 속성에 접근할 필요가 있다면` 클래스 메소드로 정의
      >
      > `클래스나 클래스 속성에 접근할 필요가 없다면` 스태틱 메소드로 정의한다.



----



#### 상속

* 부모 클래스의 모든 속성이 자식 클래스에게 상속해서, 코드의 재사용성이 높아진다.

  ```python
  #class 하고 이름은 파스칼케이스
  class ChildClass(ParentClass):
      <code block>
  ```

  - 이처럼 공통된 속성이나 메소드를 부모 클래스에 정의하고 이를 상속받아서 다양한 자식 클래스를 생성할 수 있다. 

* 클래스 상속 검사

  ```python
  # 상속 관계 여부를 확인하는 내장함수
  issubclass(자식클래스, 부모클래스)
  
  # 인스턴스인지 여부를 확인하는 내장함수
  isinstance(인스턴스명, 클래스명)
  ```



- `super()` 

  - 자식 클래스에서 부모클래스의 메소드를 사용하고자 할 때 사용

  - super는 자식클래스의 부모클래스를 의미

    ```python
    class ChildClass(ParentClass):
        def method(self, arg):
            super().method(arg)
    ```

    

- 메소드 오버라이딩
  
  - `자식클래스에서 부모클래스의 메소드를 재정의`하는 것
- 상속 관계에서의 이름공간
  - 인스턴스 -> 클래스 -> 전역
  - 인스턴스 -> 자식클래스 -> 부모클래스 -> 전역
- 다중상속
  - 두 개 이상의 클래스를 상속 받는 경우
  - 상속 순서가 중요( 왼쪽 -> 오른쪽 )