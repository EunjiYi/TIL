### url resolver

* 웹 브라우저에서 요청을 서버로 전달하고 서버에서 주소를 받아 브라우저에 제공하는 기능을 수행

* Django에서 url resolver는 `urls.py`에서 정의한 `path`

* reverse() 함수가 존재하는데 이 함수는 url resolvers 모듈 안에 있는 메서드

  * redirect("articles:index", articles.pk) 이렇게 사용했던 redirect도 reverse 함수를 사용한다.
  * app_name과 path의 name에 일치하는 실제 주소창에 입력되는 `/article/1/`을 찾아준다. 
  * 찾지 못하면, NoReversMatch 오류가 발생한다.

* 결과적으로 resolver라는 건 실제 주소창에 입력되는 주소와 장고 내부에서 사용하는 url을 서로 번역해주는 역할을 한다.

  



### Password 암호화

* 보안시스템이 강한지 약한지 확인하는 방법은 가장 약한 부분이 얼만큼 강한지에 따라서 결정된다.

* PBKDF2

  * NIST(미국표준기술연구소)에 의해서 인증된 암호화 방식
  * 미국 정부 시스템에서도 패스워드 관리할 때 사용

  

* 패스워드를 저장하는 방식

  * 있는 그대로 저장

  * 암호화를 시킨다.

    * 단방향 해쉬함수를 이용해서 암호화를 시킴
      * 단반향이란?
        * 메시지를 암호화하기는 쉽지만 그 반대는 불가능한 것
        * 암호화된 해쉬데이터를 다이제스트라고 부른다. 
    * 다이제스트를 DB에 저장을 한다.

  * 단방향 해쉬 함수의 문제점

    * 동일한 메세지는 동일한 해시값을 가진다.

    * 속도가 빨라서 문제.

      * MD5라는 알고리즘: 1초에 56억번을 무작위로 대입연산(때려넣을 수)할 수 있다.

        > 비유: 1초에 도어락 비번을 56억번씩 눌러볼 수 있다....

      * 그래서 해커는 개이득, 서버 측에서는 난감 

  * 단방향 해쉬함수의 보완
    * Salt + 메세지 암호화: 음식에 소금을 치듯이 같은 암호화 알고리즘이어도 같은 문자열이 다른 해시값으로 나온다.
      * Salt는 랜덤한 문자열
      * 동일한 메세지라도, 동일한 hash 값이 아닌 다른 hash 값을 가지게 됨
    * 속도가 빠른 문제를 해결하기 위해서 iteration을 한다.
      * 반복해서 hash 데이터를 생성한다. (한번 hash 나온 걸 또 넣어서 그걸 hash로 얻고 또 얻고 반복)
      * 반복 횟수를 가지고 있으면 암호화 할 수 있음
      * 반복 횟수가 많으면 시간도 많이 걸리니까 1초에 5번 정도로 대입연산 속도를 늦출 수 있다.



* 장고에서는 어떻게 비밀번호를 비교??
  * 기존 비밀번호는 이미 솔트와 반복횟수로 암호화 되어 있음
  * DB에, 암호화된 다이제스트와 해당 유저의 솔트값과 반복횟수를 저장
  * 입력되는 password 를 해당 값들로 암호화해서 다이제스트를 만든 뒤 
  * 그 다이제스트끼리 비교함.
  * 즉 직접적으로 비밀번호를 저장하고 있는 것은 아니다.

