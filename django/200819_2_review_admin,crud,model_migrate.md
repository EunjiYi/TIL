프로젝트 생성

앱생성 articles

셋팅즈에 앱등록, ko-kr 아시아/서울

유알엘등록(urls.py)

include

```python


from django.contrib import admin

from django.urls import path, include



urlpatterns = [

  path('admin/', admin.site.urls),

  path('articles/', include('articles.urls')), #1차패턴지정(/articles)후 2차패턴은 인클루드로nclude('articles.urls').

]

```



articles에 urls.py 새로 파일 만들고 이거 쓰기

```python
from django.urls import path

app_nmae = "articles"
urlpatterns = [

]
# 이렇게 하면 유알엘 분리까지 끝.
```





이제 모델 정의하자.

models.py

```python
from django.db import models

# Create your models here.
class Article(models.Model): #상속받아오자.
    #클래스변수(title, content, created_at) 하나씩 설정
    title = models.CharField(max_length=100) #CharField를 사용할 때는 꼭 max_length를 지정해주세요.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
```



마이그레이션 하기

python manage.py makemigrations - 데이터베이스 설계도 찾음.



생성된 0001_initial.py 로 가기

```python
# Generated by Django 3.1 on 2020-08-20 00:27

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Article',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=100)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
이렇게 적혀있을 텐데, 여기서는 직접 수정하는게 아니고 오타를 확인한다.!

```

만약 수정하고 다시 마이그레이션했으면   y하고 엔터



맨처음 아무 설게도 없이 charField쓰면 괜찮은데,

설계도가 있는 상태에서 CharField를 또 쓰면  defualt 값 설정하라는 안내가 나온다.

장고입장에서 기존에 컬럼이 생길때 데이터도 다 들어있다고 생각하기 때문에 새로운 컬럼 추가시 안에 데이터(defualt)도 넣어달라고 메세지가 나오는 것

그냥 defualt를 줘서 1로 해도 되고, 아니면 timenow.()를 해서 현재시간을 데이터로 박아넣어도된다.





python manage.py migrate - 실제로 db에 테이블 생성하는 단계



sqlite extension 설치



db3.sqlite3 오/마 -> open database

sqlite explorer 보기



pip install django-extensions 설치 / ipython 없으면 설치하기. 주피터노트북설치시에 되서 일단 나는 생략

settings.py에 등록하기

```python
INSTALLED_APPS = [
    'articles',

    'django_extensions',
    
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
```



shell: import를 필요한걸 매번 직접해야함.

`python manage.py shell_plus`

shell_plus import를 대신 해줌

-> 서버가 대부분 리눅스 환경이라 알아둬야한다. 



이제 crud하자.



#### create 부터, 

방법 1

```python
In [2]: Article.objects.all()
Out[2]: <QuerySet []>

In [3]: article = Article()

In [4]: article
Out[4]: <Article: Article object (None)>

In [5]: article.title = 'first'

In [6]: article.content = 'django!'

In [7]: article.title
Out[7]: 'first'
-> 이건 aritcle 인스턴스에 저장된거지 DB에 저장된 것이 아니다. 
이거 DB에 저장하려면 aricle.save()해줘야한다.!
```



방법2

```python
article = Article(title='second', content='django!!')
-> 이 상태는 인스턴스객체에만 저장됨. 데이터베이스에 적용된 내용은 아니다.

>>> article
<Article: Article object (None)>

#save해야함.
>>> article.save()
>>> article
<Article: Article object (2)>
>>> Article.objects.all()
<QuerySet [<Article: Article object (1)>, <Article: Article object (2)>]>
```



방법3

```python
>>> article = Article.objects.create(title='third', content='django!')
>>> article #save안해도 위에서 바로 같이 됨.
<Article: Article object (3)>
```

`create()` 를 사용하면 쿼리셋 객체를 생성하고 저장하는 로직이 한번의 스텝으로 가능





- `__str__`

```
    def __str__(self):
        return self.title
```

models.py

```python
<Article: Article object (3)> 이렇게만 나오면 뭔지 모르니까 알아보기 쉬운 걸(보통 첫번째 필드로 많이 쓴다. ex. title)로 리턴되도록 설정한다.
    
    from django.db import models

# Create your models here.
class Article(models.Model): #상속받아오자.
    #클래스변수(title, content, created_at) 하나씩 설정
    title = models.CharField(max_length=100) #CharField를 사용할 때는 꼭 max_length를 지정해주세요.
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title -> 이건 필드의 정보를 읽어오는 거여서 데이터에 직접적인 영향을 주지 않기 때문에 다시 migrate할 필요 없다.그냥 shell_plus exit()로 나가고 다시 들어가서 확인하면 된다. python manage.py shell_plus로 들어가서 다시 보면,
    
```

In [1]: Article.objects.all()
Out[1]: <QuerySet [<Article: first>]>

이렇게 나옴.





#### read

 Article.objects.get(id=1) #`하나의 객체`를 리턴해주는 함수 `get()`

>  다중 데이터를 리턴받을 때는 `QuerySet`

데이터가 두 개이상 존재하는 것을 불러올려고 하면(ex) Aricles.objects.get(content='django!') -  지금 컬럼1이랑 컬럼4가 둘다 django!임.)

MultipleOjectsReturned오류 발생





여러개 가져오려면 filter사용

지정된 조회 매개 변수와 일치하는 객체를 포함하는 새 QuerySet을 반환

```python
>>> Article.objects.filter(content='django!')
<QuerySet [<Article: first>, <Article: fourth>]>
```





#### update

```python
변경하려는 자료를 일단 가져와야함
# UPDATE articles SET title='byebye' WHERE id=1;
>>> article = Article.objects.get(pk=1)
>>> article.title
'first'

# 값을 변경하고 저장하면 변경된거 볼 수 있다.
>>> article.title = 'byebye'
>>> article.save()

>>> article.title
'byebye'
```



#### delete 제일 쉬움

```python
>>> article = Article.objects.get(pk=1)

>>> article.delete()
(1, {'articles.Article': 1})

# 다시 1번 글을 찾으려고 하면 없다고 나옴
>>> Article.objects.get(pk=1)
DoesNotExist: Article matching query does not exist.
```





------

------

gui로도 모델을 관리할 수 있다.

먼저 서버 실행시키기

python manage.py runserver

장고에서 만들어준 admin 페이지(200-300만원 절약한셈...ㅎ)



python manage.py createsuperuser

admin

엔터

```
aclass@M805 MINGW64 ~/Desktop/0820/0819ws/django_remind
$ python manage.py createsuperuser
사용자 이름 (leave blank to use 'aclass'): admin
이메일 주소:
Password:
Password (again):
비밀번호가 사용자 이름와 너무 유사합니다.
비밀번호가 너무 짧습니다. 최소 8 문자를 포함해야 합니다.
비밀번호가 너무 일상적인 단어입니다.
Bypass password validation and create user anyway? [y/N]: y
Superuser created successfully.
```



사용자 수정/추가/삭제를 UI에서도 할 수 있따.



유저말고 데이터를 관리자페이지에서 관리하고 싶으면.

admin.py에서

```python
# articles/admin.py

from django.contrib import admin
from .models import Article # 명시적 상대경로 표현

admin.site.register(Article)
```

이렇게 하고 관리자페이지 다시 보면,

Articles가 뜬당.

